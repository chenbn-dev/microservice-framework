要完整跑通所有的微服务，请参考该文档。

构建一个模块的固定步骤：1.建modle；2.修改pom.xml；3.添加yml；4.建主启动类；5.建业务类

1.第一个模块：微服务的提供者，cloud-provider-payment8001（注意数据库库名和账号密码配置。）（业务类细节，请参考各类型文件注释）。
  启动 PaymentMain8001 主启动类，测试get查询方法和post插入数据方法：
  get请求地址： http://localhost:8001/payment/get/1          （注意，数据库要插入1号数据）
  post请求地址：http://localhost:8001/payment/create?serial=chbn002  （postman测试地址）

2.第二个模块：客户端消费者。cloud-consumer-order80，80服务要去调用8001的服务，最原始的方式就会HttpClient；
  这里我们用restTemplate，相当于将HttpClient做了一次封装，实现了订单微服务和支付微服务之间的横向调用，完成80到8001的
  远程调用（restTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问
  Rest服务的客户端模板工具集）。
  RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集
  官网：
  https://docs.spring.io/spring-framework/docs/4.3.7.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html
  使用restTemplate访问restful接口非常的简单粗暴无脑。
   (url, requestMap, ResponseBean.class)这三个参数分别代表
   REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。

  先启动8001服务，然后启动80服务。访问：http://localhost/consumer/payment/get/1  80端口号可以省略，端口号不要暴露给消费者。
  没有写端口号默认就是80，模拟从外部互联网访问，只要路径中加“consumer”就说明来自消费者。
  查询到数据即成功。

  插入操作访问：http://localhost/consumer/payment/create?serial=cbn001

  代码重构：通过maven的聚合父工程，将相同，相似重复的代码，将其提到一个公开公用的工程中，供各子系统统一调用。

3.新建新的工程cloud-api-commons，可以提交我们重复的代码，而且我们的一些服务接口及第三方接口，工具类，都可以放在这个工程里面。因为不对外暴露，所以没有端口号
  将公共模块打包发布到maven本地仓库，将80和8001中的entitis包即下面的类删除，在它们的pom.xml当中引入坐标。启动测试。

4.新建eureka server类：cloud-eureka-server7001，服务注册中心，主要就是注册，不需要在写业务类，注意标明@EnableEurekaServer注解，表示
  该类是一个eureka server。
  启动该模块组启动类，访问：localhost:7001
  将cloud-provider-payment8001注册进EurekaServer；将cloud-consumer-order80注册进EurekaSrever

5.新建cloud-eureka-server7002，cloud-eureka-server7003，cloud-eureka-server7004服务，搭建Eureka集群。
  pom.xml添加依赖，添加application.yml配置文件，hosts文件做端口映射，模拟集群环境，相继启动4个服务，
  逐一访问"http://eureka7002.com:7002/"这4个服务，看集群是否搭建成功。

6.配置8001和80的yml文件，将8001和80两个微服务，注册进eureka集群。

7.搭建服务提供者集群，然后修改端口8001——8005逐一测试服务提供者是否正常：" http://localhost:8001/payment/get/1 "，如果所有服务提供
  者服务全部能正常提供服务，则将消费者80默认访问地址"http://localhost:8001"改为服务提供者集群名称"http://cloud-payment-service",
  并在消费者80的配置类中添加"@LoadBalanced"注解，以提供默认的负载均衡功能，测试通过Eureka集群服务提供者是否能够为消费者80，提供正常的服务"http://localhost/consumer/payment/get/1"。
8.完善微服务信息
9.服务的发现：对于注册eureka里面的微服务,可以通过服务发现来获得该服务的信息。
  微服务自身要对外提供一种功能，它的IP，服务名称，端口号等；
  即Eureka中注册了这么多服务，那么它对外暴露的服务，各自的信息是什么？说白了就是拿到Eureka上面注册成功的微服务的信息
  8001~8005统统注册进Eureka集群，假设80想看看端口号，服务名，怎么能取得到信息。
  修改8001的Controller。不在客户端上面配置，通过访问8001端口，自测来看看关于8001的微服务有哪些内容。
10.Eureka的自我保护：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。
   禁用Eureka的自我保护机制。


















































