要完整跑通所有的微服务，请参考该文档。

构建一个模块的固定步骤：1.建modle；2.修改pom.xml；3.添加yml；4.建主启动类；5.建业务类

1.第一个模块：微服务的提供者，cloud-provider-payment8001（注意数据库库名和账号密码配置。）（业务类细节，请参考各类型文件注释）。
  启动 PaymentMain8001 主启动类，测试get查询方法和post插入数据方法：
  get请求地址： http://localhost:8001/payment/get/1          （注意，数据库要插入1号数据）
  post请求地址：http://localhost:8001/payment/create?serial=chbn002  （postman测试地址）

2.第二个模块：客户端消费者。cloud-consumer-order80，80服务要去调用8001的服务，最原始的方式就会HttpClient；
  这里我们用restTemplate，相当于将HttpClient做了一次封装，实现了订单微服务和支付微服务之间的横向调用，完成80到8001的
  远程调用（restTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问
  Rest服务的客户端模板工具集）。
  RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集
  官网：
  https://docs.spring.io/spring-framework/docs/4.3.7.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html
  使用restTemplate访问restful接口非常的简单粗暴无脑。
   (url, requestMap, ResponseBean.class)这三个参数分别代表
   REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。

  先启动8001服务，然后启动80服务。访问：http://localhost/consumer/payment/get/1  80端口号可以省略，端口号不要暴露给消费者。
  没有写端口号默认就是80，模拟从外部互联网访问，只要路径中加“consumer”就说明来自消费者。
  查询到数据即成功。

  插入操作访问：http://localhost/consumer/payment/create?serial=cbn001

  代码重构：通过maven的聚合父工程，将相同，相似重复的代码，将其提到一个公开公用的工程中，供各子系统统一调用。

3.新建新的工程cloud-api-commons，可以提交我们重复的代码，而且我们的一些服务接口及第三方接口，工具类，都可以放在这个工程里面。因为不对外暴露，所以没有端口号
  将公共模块打包发布到maven本地仓库，将80和8001中的entitis包即下面的类删除，在它们的pom.xml当中引入坐标。启动测试。

4.新建eureka server类：cloud-eureka-server7001，服务注册中心，主要就是注册，不需要在写业务类，注意标明@EnableEurekaServer注解，表示
  该类是一个eureka server。
  启动该模块组启动类，访问：localhost:7001
  将cloud-provider-payment8001注册进EurekaServer；将cloud-consumer-order80注册进EurekaSrever

5.新建cloud-eureka-server7002，cloud-eureka-server7003，cloud-eureka-server7004服务，搭建Eureka集群。
  pom.xml添加依赖，添加application.yml配置文件，hosts文件做端口映射，模拟集群环境，相继启动4个服务，
  逐一访问"http://eureka7002.com:7002/"这4个服务，看集群是否搭建成功。
6.配置8001和80的yml文件，将8001和80连个微服务，注册进eureka集群。









